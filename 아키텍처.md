# Samyang 2.0 아키텍처 설계

## 프로젝트 개요
Spring Boot 3.5.3 + MyBatis + MySQL 기반의 CRUD 애플리케이션

## 핵심 설계 원칙
1. **단순성**: 불필요한 복잡성 제거
2. **일관성**: DB 스키마와 코드 완벽 일치
3. **안정성**: 검증된 패턴만 사용
4. **확장성**: 최소한의 구조로 확장 가능

## 기술 스택
- **Java**: 17
- **Spring Boot**: 3.5.3
- **MyBatis**: 3.0.5
- **MySQL**: 8.0+
- **Build**: Gradle 8.x

## 디렉토리 구조
```
samyang2.0/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/farm404/samyang/
│   │   │       ├── SamyangApplication.java
│   │   │       ├── controller/
│   │   │       ├── service/
│   │   │       ├── mapper/
│   │   │       ├── entity/
│   │   │       ├── dto/
│   │   │       └── config/
│   │   └── resources/
│   │       ├── mapper/
│   │       ├── application.yml
│   │       └── schema.sql
│   └── test/
├── build.gradle
└── README.md
```

## 레이어 아키텍처

### 1. Controller Layer
- REST API 엔드포인트 정의
- 요청/응답 처리
- 입력 검증 (Bean Validation)

### 2. Service Layer  
- 비즈니스 로직 처리
- 트랜잭션 관리
- DTO ↔ Entity 변환

### 3. Mapper Layer (MyBatis)
- SQL 쿼리 실행
- Entity 매핑
- 결과 반환

### 4. Entity Layer
- DB 테이블과 1:1 매핑
- 컬럼명 정확히 일치
- 불변 객체로 설계

## 데이터베이스 설계

### 명명 규칙
- 테이블명: PascalCase (예: User, Comment)
- 컬럼명: PascalCase (예: UserID, CreatedAt)
- MyBatis에서 대소문자 정확히 일치

### 핵심 테이블
1. **User**: 사용자 정보
2. **Crop**: 작물 정보
3. **FarmingDiary**: 영농일지
4. **Comment**: 댓글
5. **Review**: 리뷰
6. **Report**: 신고
7. **PaymentMethod**: 결제수단

## Entity 설계 원칙

### 1. DB 스키마 완벽 일치
```java
@Data
public class Comment {
    private Integer commentID;
    private Integer postID;      // NOT NULL
    private Integer userID;      // NOT NULL
    private String content;      // NOT NULL
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```

### 2. 타입 매핑 규칙
- DB `int` → Java `Integer`
- DB `varchar` → Java `String`
- DB `datetime` → Java `LocalDateTime`
- DB `date` → Java `LocalDate`
- DB `tinyint(1)` → Java `Boolean`

## MyBatis 설정

### 1. 설정 원칙
- XML Mapper 파일 사용
- 동적 SQL 최소화
- 명시적 resultMap 정의

### 2. Mapper XML 규칙
```xml
<mapper namespace="com.farm404.samyang.mapper.CommentMapper">
    <resultMap id="CommentResultMap" type="com.farm404.samyang.entity.Comment">
        <id property="commentID" column="CommentID"/>
        <result property="postID" column="PostID"/>
        <result property="userID" column="UserID"/>
        <result property="content" column="Content"/>
        <result property="createdAt" column="CreatedAt"/>
        <result property="updatedAt" column="UpdatedAt"/>
    </resultMap>
</mapper>
```

## DTO 설계

### DTO 설계 원칙
1. **요청/응답 분리**: CreateRequest, UpdateRequest, Response로 구분
2. **Lombok 활용**: @Data, @Builder 등으로 보일러플레이트 코드 최소화
3. **Validation**: Bean Validation으로 입력값 검증
4. **단순성**: 최소한의 필드로 명확한 목적 달성

### 요청 DTO 예시
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CommentCreateRequest {
    @NotNull
    private Integer postID;
    
    @NotBlank
    @Size(max = 1000)
    private String content;
}
```

### 응답 DTO 예시
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CommentResponse {
    private Integer commentID;
    private Integer postID;
    private Integer userID;
    private String userName;
    private String content;
    private LocalDateTime createdAt;
}
```

### 공통 DTO
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageRequest {
    @Min(1)
    private int page = 1;
    
    @Min(1)
    @Max(100)
    private int size = 10;
    
    private String sortBy = "createdAt";
    private String sortDirection = "DESC";
}
```

## API 설계

### RESTful 원칙
- GET: 조회
- POST: 생성
- PUT: 전체 수정
- PATCH: 부분 수정
- DELETE: 삭제

### URL 패턴
```
GET    /api/users           # 사용자 목록
POST   /api/users           # 사용자 생성
GET    /api/users/{id}      # 사용자 조회
PUT    /api/users/{id}      # 사용자 수정
DELETE /api/users/{id}      # 사용자 삭제
```

## 트랜잭션 전략
- Service Layer에서 @Transactional 사용
- 읽기 전용 메서드는 @Transactional(readOnly = true)
- 명시적 롤백 처리

## 예외 처리
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(EntityNotFoundException e) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(new ErrorResponse("NOT_FOUND", e.getMessage()));
    }
}
```

## 보안 고려사항
1. SQL Injection 방지 (MyBatis 파라미터 바인딩)
2. XSS 방지 (입력값 검증)
3. 패스워드 암호화 (BCrypt)
4. CORS 설정

## 성능 최적화
1. N+1 문제 방지 (JOIN 사용)
2. 페이징 처리
3. 인덱스 활용
4. 커넥션 풀 설정

## 테스트 전략
1. 단위 테스트 (Service Layer)
2. 통합 테스트 (Controller Layer)
3. MyBatis Mapper 테스트
4. @SpringBootTest 활용

## 배포 고려사항
1. 환경별 설정 분리 (application-{profile}.yml)
2. 로깅 설정
3. 모니터링
4. 백업 전략